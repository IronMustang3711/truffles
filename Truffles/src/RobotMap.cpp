// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

using namespace frc;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<CANTalon> RobotMap::leftFrontController;
std::shared_ptr<CANTalon> RobotMap::leftRearController;
std::shared_ptr<CANTalon> RobotMap::rightFrontController;
std::shared_ptr<CANTalon> RobotMap::rightRearController;
std::shared_ptr<RobotDrive> RobotMap::chassisDrive;
std::shared_ptr<CANTalon> RobotMap::shooterController;
std::shared_ptr<Spark> RobotMap::intakeController;
std::shared_ptr<Spark> RobotMap::winchController;
std::shared_ptr<Spark> RobotMap::hexapusController;
std::shared_ptr<Servo> RobotMap::gearCatchActuator1;
std::shared_ptr<Servo> RobotMap::gearCatchActuator2;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<PowerDistributionPanel> RobotMap::powerDistributionPanel;

 std::shared_ptr<AHRS> RobotMap::ahrs;
std::shared_ptr<Solenoid> RobotMap::lightsRed;
std::shared_ptr<Solenoid> RobotMap::lightsGreen;
std::shared_ptr<Solenoid> RobotMap::lightsBlue;



/* some BS about Abstract classes */
//class MyRobotDrive : public RobotDrive {
//public:
//    MyRobotDrive(const std::shared_ptr<SpeedController> &frontLeftMotor,
//                 const std::shared_ptr<SpeedController> &rearLeftMotor,
//                 const std::shared_ptr<SpeedController> &frontRightMotor,
//                 const std::shared_ptr<SpeedController> &rearRightMotor)
//            : RobotDrive(frontLeftMotor, rearLeftMotor,
//                         frontRightMotor, rearRightMotor) {}
//
//};
//
//class MySpark : public Spark {
//public:
//    MySpark(int channel) : Spark(channel) {}
//
//};

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    leftFrontController.reset(new CANTalon(2));
    lw->AddActuator("Chassis", "LeftFront", leftFrontController);


    leftRearController.reset(new CANTalon(5));
    lw->AddActuator("Chassis", "LeftRear", leftRearController);

    rightFrontController.reset(new CANTalon(1));
    lw->AddActuator("Chassis", "RightFront", (rightFrontController));

    rightRearController.reset(new CANTalon(4));
    lw->AddActuator("Chassis", "RightRear", (rightRearController));

    auto configDriveTalon = [](std::shared_ptr<CANTalon> t){
        t->SetFeedbackDevice(CANTalon::QuadEncoder);
        t->ConfigEncoderCodesPerRev(2916);
        t->SetSensorDirection(true);
        t->SetPosition(0);
        t->ConfigLimitMode(CANSpeedController::kLimitMode_SrxDisableSwitchInputs);

    };

    configDriveTalon(leftFrontController);
    configDriveTalon(leftRearController);
    configDriveTalon(rightFrontController);
    configDriveTalon(rightRearController);

    chassisDrive.reset(new RobotDrive(leftFrontController, leftRearController,
                                        rightFrontController, rightRearController));

    chassisDrive->SetSafetyEnabled(false);
    chassisDrive->SetExpiration(0.1);
    chassisDrive->SetSensitivity(0.5);
    chassisDrive->SetMaxOutput(1.0);

    chassisDrive->SetInvertedMotor(RobotDrive::kFrontRightMotor, true);
    chassisDrive->SetInvertedMotor(RobotDrive::kRearRightMotor, true);

    shooterController.reset(new CANTalon(3));
    lw->AddActuator("Shooter", "ShooterMotor", shooterController);


    intakeController.reset(new Spark(2));
    lw->AddActuator("Intake", "IntakeMotor", (intakeController));

    winchController.reset(new Spark(1));
    lw->AddActuator("Winch", "WinchMotor", (winchController));

    hexapusController.reset(new Spark(0));
    lw->AddActuator("Shooter", "hexopus", hexapusController);

    gearCatchActuator1.reset(new Servo(3));
    lw->AddActuator("Gear Catch","linear actuator 1", gearCatchActuator1);

    gearCatchActuator2.reset(new Servo(4));
    lw->AddActuator("Gear Catch","linear actuator 2", gearCatchActuator2);

   ahrs.reset(new AHRS(SPI::Port::kMXP));






    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS



    powerDistributionPanel.reset(new PowerDistributionPanel(10));
    lw->AddSensor("Robot", "power distribution", powerDistributionPanel);

    lightsRed.reset(new Solenoid(20,0));
    lw->AddActuator("Lipstick","red(0)",lightsRed);

    lightsGreen.reset(new Solenoid(20,1));
    lw->AddActuator("Lipstick","green(1)",lightsGreen);

    lightsBlue.reset(new Solenoid(20,2));
    lw->AddActuator("Lipstick","blue(2)",lightsBlue);




}

const PowerDistributionPanel &RobotMap::getPowerDistributionPanel() {
    return *powerDistributionPanel.get();
}

