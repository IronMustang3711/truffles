// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Shooter.h"
#include "../RobotMap.h"
#include <PIDSource.h>
#include <memory>
#include <functional>
#include "../pid/DelegatingPIDSource.h"
using namespace frc;

// TODO: std::bind!
struct CANTalonErrorSourceFunctor {
 public:
  std::shared_ptr<CANTalon> talon;
  CANTalonErrorSourceFunctor(std::shared_ptr<CANTalon> ptr) : talon{ptr} {}
  double operator()(void) { return talon->GetClosedLoopError(); }
};

Shooter::Shooter()
    : Subsystem("Shooter"),
      shooterController(RobotMap::shooterController),
      errorFilter(LinearDigitalFilter::SinglePoleIIR(
          std::make_shared<DelegatingPIDSource>(
              CANTalonErrorSourceFunctor(RobotMap::shooterController)),
          1.0,
          5.0)),
      setpointUpdateTimer{}

{
  initShooter();
}

double map(double in,
           double inputMin,
           double inputMax,
           double outputMin,
           double outputMax) {
  return outputMin +
         (outputMax - outputMin) * ((in - inputMin) / (inputMax - inputMin));
}

void Shooter::initShooter() {
  shooterController->SetFeedbackDevice(CANTalon::QuadEncoder);
  shooterController->ConfigEncoderCodesPerRev(20);
  shooterController->SetSensorDirection(true);
  shooterController->SetPosition(0);
  shooterController->SetControlMode(CANSpeedController::ControlMode::kSpeed);
  shooterController->SetClosedLoopOutputDirection(false);
  shooterController->ConfigNominalOutputVoltage(+1.0, -0.0);
  shooterController->ConfigPeakOutputVoltage(12.0, 0.0);
  shooterController->SetAllowableClosedLoopErr(0); /* always servo */
  shooterController->SetF(1.45);
  shooterController->SetP(1.0);
  shooterController->SetI(0.0);
  shooterController->SetD(0.0);
  shooterController->SetCloseLoopRampRate(0.0);
}

void Shooter::InitDefaultCommand() {}

Shooter::State Shooter::getState() {
  return state;
}

bool Shooter::isOff(double requestedSpeed) {
  return requestedSpeed == 0.0 || requestedSpeed == 10.0;
}

bool Shooter::isShooting() {
  return getClosedLoopError() - prevClosedLoopError > 50.0 &&
         getSetPoint() == prevSetPoint;
}

void Shooter::run(double speed) {
  double sp = getSetPoint();
  double vel = getVelocity();
  double err = getClosedLoopError();
  double out = getOutput();

  if (isOff(speed)) {
    transition(OFF);
  }
  switch (state) {
    case OFF:
      if (!isOff(speed)) {
        transition(INIT);
      }
      break;

    case INIT:
      if (std::abs(prevClosedLoopError - err) <= 1.) {
        transition(STEADY);  // error not changing much, transition to steady
      } else if (isShooting()) {
        transition(SHOOT);  // large increase in error, not caused by change in
                            // setpoint
      } else {
        // still initializing
      }
      break;

    case SHOOT:
      if (std::abs(prevVelocity - vel < 10) ||
          std::abs(prevClosedLoopError - err) < 5.0) {
        // deceleration is over
        // TODO keep track of acceleration!
        transition(BANG_BANG);
      }
      break;

    case BANG_BANG:
      if (std::abs(prevClosedLoopError - err) <= 1.) {
        transition(STEADY);
      } else if (err - prevClosedLoopError > 20.0 && sp == prevSetPoint) {
        transition(SHOOT);
      }
      break;

    case STEADY:
      if (isShooting()) {
        transition(SHOOT);
      }
      break;
  }
  shooterController->Set(speed);
  prevSetPoint = sp;
  prevVelocity = vel;
  prevClosedLoopError = err;
  prevOutput = out;
}

void Shooter::runShooterMotor(double input) {
  double target = input < 0.1 ? (10 + 31900.0 * input)
                              : map(input, 0.1, 1.0, 3200.0, 4200.0);

  run(target);

  // shooterController->Set(target);

  //  SmartDashboard::PutString("shooter state", StateName(state));
  //  SmartDashboard::PutNumber("shooter output", prevOutput);
  //  SmartDashboard::PutNumber("shooter:target", target);
  //  // SmartDashboard::PutNumber("shooter:input", input);
  //  SmartDashboard::PutNumber("shooter:speed", prevVelocity);
  //  SmartDashboard::PutNumber("Shooter:error", prevClosedLoopError);

  GetTable()->PutNumber("setpoint", prevOutput);
  GetTable()->PutNumber("velocity", target);
  GetTable()->PutNumber("error", prevClosedLoopError);
  GetTable()->PutNumber("error(lowpass)", errorFilter.Get());
  GetTable()->PutNumber("output", prevOutput);
}

double Shooter::getSetPoint() {
  return shooterController->GetSetpoint();
}

double Shooter::getVelocity() {
  return shooterController->GetSpeed();
}

double Shooter::getClosedLoopError() {
  // return errorFilter.Get();
  return shooterController->GetClosedLoopError();
}

double Shooter::getOutput() {
  return shooterController->GetOutputVoltage() /
         shooterController->GetBusVoltage();
}

std::string Shooter::StateName(Shooter::State s) {
  switch (s) {
    case OFF:
      return "OFF";
    case INIT:
      return "INIT";
    case SHOOT:
      return "SHOOT";
    case BANG_BANG:
      return "BANG_BANG";
    case STEADY:
      return "STEADY";
  }
  return "butts";
}

void Shooter::transition(Shooter::State newState) {
  if (state == OFF && newState == INIT) {
    initShooter();
  }
  if (newState == BANG_BANG) {
    shooterController->SetD(0);
  }
  if (state == BANG_BANG) {
    shooterController->SetD(100.0);
  }
  GetTable()->PutString("state", StateName(newState));

  state = newState;
}
void Shooter::InitTable(std::shared_ptr<ITable> subtable) {
  subtable->PutString("state", StateName(state));
  subtable->PutNumber("setpoint", 0);
  subtable->PutNumber("target", 0);
  subtable->PutNumber("velocity", 0);
  subtable->PutNumber("error", 0);
  subtable->PutNumber("error(lowpass)", 0);
  subtable->PutNumber("output", 0);
}
