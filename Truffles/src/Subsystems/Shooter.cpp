// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Shooter.h"
#include "../RobotMap.h"

Shooter::Shooter() : Subsystem("Shooter") {
  shooterController = RobotMap::shooterController;

  initShooter();
}

double map(double in,
           double inputMin,
           double inputMax,
           double outputMin,
           double outputMax) {
  return outputMin +
         (outputMax - outputMin) * ((in - inputMin) / (inputMax - inputMin));
}

void Shooter::initShooter() {
  shooterController->SetFeedbackDevice(CANTalon::QuadEncoder);
  shooterController->ConfigEncoderCodesPerRev(20);
  shooterController->SetSensorDirection(true);
  shooterController->SetPosition(0);
  shooterController->SetControlMode(CANSpeedController::kSpeed);
  shooterController->SetClosedLoopOutputDirection(false);
  shooterController->ConfigNominalOutputVoltage(+0., -0.0);
  shooterController->ConfigPeakOutputVoltage(12.0, -12.0);
  shooterController->SetAllowableClosedLoopErr(0); /* always servo */
  shooterController->SetF(1.45);
  shooterController->SetP(1.0);
  shooterController->SetI(0.0);
  shooterController->SetD(0.0);
  shooterController->SetCloseLoopRampRate(0.0);
}

void Shooter::InitDefaultCommand() {}

void Shooter::run(double speed){
  shooterController->Set(speed);

  double sp = getSetPoint();
  double vel = getVelocity();
  double err = getClosedLoopError();
  double out = getOutput();

  if (speed == 0.0) {
    state = OFF;
  }
  switch (state) {
    case OFF:
      if (speed != 0.0) {
        state = INIT;
        initShooter();
      }
      break;

    case INIT:
      if (err <= 20.0) {
        state = STEADY;
      } else if (err - prevClosedLoopError > 50.0 && sp == prevSetPoint) {
        state = SHOOT;
      }
      break;

    case SHOOT:
      if (prevVelocity - vel < 10 && prevSetPoint == sp) {
        state = BANG_BANG;
      }
      break;

    case BANG_BANG:
      if (err <= 20.0 ) {
        state = STEADY;
      } else if (err - prevClosedLoopError > 50.0 && sp == prevSetPoint) {
        state = SHOOT;
      }
      break;

    case STEADY:
      if (prevVelocity - vel > 50 && prevSetPoint == sp) {
        state = SHOOT;
      }
      break;
  }
  prevSetPoint = sp;
  prevVelocity = vel;
  prevClosedLoopError = err;
  prevOutput = out;
  SmartDashboard::PutString("shooter state", StateName(state));
}

void Shooter::runShooterMotor(double input) {
  double target = input < 0.1 ? (10 + 31900.0 * input)
                              : map(input, 0.1, 1.0, 3200.0, 4200.0);

  run(target);

 // shooterController->Set(target);

  SmartDashboard::PutNumber("shooter:target", target);
  // SmartDashboard::PutNumber("shooter:input", input);
  SmartDashboard::PutNumber("shooter:speed", shooterController->GetSpeed());
  SmartDashboard::PutNumber("Shooter:error",
                            shooterController->GetClosedLoopError());
}


double Shooter::getSetPoint() {
  return shooterController->GetSetpoint();
}

double Shooter::getVelocity() {
  return shooterController->GetSpeed();
}

double Shooter::getClosedLoopError() {
  return shooterController->GetClosedLoopError();
}

double Shooter::getOutput() {
  return shooterController->GetOutputVoltage() /
         shooterController->GetBusVoltage();
}

std::string Shooter::StateName(Shooter::State s) {
  switch (s) {
    case OFF:
      return "OFF";
    case INIT:
      return "INIT";
    case SHOOT:
      return "SHOOT";
    case BANG_BANG:
      return "BANG_BANG";
    case STEADY:
      return "STEADY";
  }
  return "butts";
}
